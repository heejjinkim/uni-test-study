## 1. 좋은 단위 테스트의 4대 요소 자세히 살펴보기


좋은 단위 테스트에는 다음 네 가지 특성이 있다.


- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

### 1.1 회귀 방지


회귀는 소프트웨어 버그다. 코드를 수정한 후 기능이 의도한 대로 작동하지 않는 경우다.

회귀가 없다면 새로운 릴리스에서 기능이 하나라도 고장 날 가능성이 높아진다.

그렇기 때문에 회귀에 대해 효과적인 보호를 개발하는 것이 중요하다.

회귀 방지 지표에 대한 테스트 저수가 얼마나 잘 나오는지 평가하려면 다음 사항을 고려해야 한다.


- 테스트 중에 실행되는 코드의 양
    - 실행되는 코드가 많을수록 테스트에서 회귀가 나타날 가능성이 높다.
- 코드 복잡도
    - 복잡한 비즈니스 로직을 나타내는 코드가 보일러플레이트 코드보다훨씬 더 중요하다.
    - 비즈니스에 중요한 기능에서 발생한 버그가 가장 큰 피해를 입히기 때문
    - 반면, 단순한 코드를 테시트하는 것은 가치가 거의 없다.
        - 딘순한 코드를 다루는 테스트는 실수할 여지가 많지 않기 때문에 회귀 오류가 많이 생기지 않는다.
- 코드의 도메인 유의성

### 1.2 두번째 요소: 리팩터링 내성


리팩터링 내성은 테스트를 빨간색(실패)로 바꾸지 않고 기본 애플리케이션 코드를 리팩터링할 수 있는지에 대한 척도다.

리팩터링 내성 지표에서 테스트 점수가 얼마나 잘 나오는지 평가하려면 테스트에서 얼마나 많이 거짓 양성이 발생하는지 살펴봐야 한다. 적을수록 좋다.
> 거짓 양성이란 기능은 완벽히 동작하지만 리팩터링으로 테스트가 실패한 경우를 나타낸다.


왜 거짓 양성을 신경쓰는가?

전체 테스트 스위트에 치명적인 영향을 줄 수 있기 때문이다. 단위 테스트의 목표는 프로젝트 성장을 지속 가능하게 하는 것이다. 테스트가 지속 가능한 성장을 하게 하는 메커니즘은 회귀 없이 주기적으로 리팩터링하고 새로운 기능을 추가할 수 있는 것이다.

거짓 양성이 빈번하면 테스트 스위트에 대한 신뢰가 서서히 떨어지며, 더 이상 믿을 만한 안저망으로 인식하지 않는다. 즉, 허위 경보로 인식이 나빠진다.

### 1.3 무엇이 거짓 양상의 원인인가?


테스트에서 발생하는 거짓 양성의 수는 테스트 구성 방식과 직접적인 관련이 있다. 테스트와 테스트 대상 시스템(SUT)의 구현 세부 사항이 많이 결합할수록 허위 경보가 더 많이 생긴다.

거짓 양성이 생길 가능성을 줄이는 방법은 해당 구현 세부 사항에서 테스트를 분리하는 것뿐이다. 테스트를 통해 SUT가 제공하는 최종 결과(관련된 절차가 아니라 식별할 수 있는 동작)를 검증하는지 확인해야 한다. 테스트는 최종 사용자의 관점에서 SUT를 검증해야 하고 최종 사용자에게 의미 있는 결과만 확인해야 한다.

테스트를 구성하기에 가장 좋은 방법은 문제 영역에 대해 이야기하는 것이다. 이러한 테스트가 실패하면, 이야기와 실제 애플리케이션 동작이 서로 분리되는 것을 의미한다.

[구현 세부 사항과 결합된 테스트 예제](https://github.com/AcornPublishing/unit-testing/blob/main/Book/Chapter4/Listing1/MessageRendererTests.cs)

### 1.4 구현 세부 사항 대신 최종 결과를 목표로 하기


테스트를 깨지지 않게 하고 리팩터링 내성을 높이는 방법은 SUT의 구현 세부 사항과 테스트 간의 결합도를 낮추는 것뿐이다.

하지만 이렇게 해도 거짓 양성이 나타날 수 있다. 예를 들어 테스트하는 메서드에 새 매개변수를 도입하면 컴파일 오류가 발생할 수 있다. 기술적으로 이러한 오류도 거짓 양성으로 간주한다. 결국 애플리케이션 동작 변경으로 인해 테스트가 실패하는 것은 아니다.

그러나 이런 종료의 거짓 양성은 해결하기 쉽다. 좋지 않은 거짓 양성은 컴파일 오류를 내지않는 것이다. 이러한 거짓 양성은 처리하기가 까다롭다.

## 2. 첫 번째 특성과 두 번째 특성 간의 본질적인 관계


좋은 단위 테스트의 처음 두 요소(회귀 방지와 리팩터링 내성) 사이에는 본질적인 관계가 있다. 둘 다 정반대의 관점에서도 테스트 스위트의 정확도에 기여한다.

프로젝트가 시작된 직후에는 회귀 방지를 휼륭히 갖추는 것이 중요한 데 반해, 리팩터링 내성은 바로 필요하지 않다.

### 2.1 테스트 정확도 극대화


코드 정확도와 테스트 결과에 대해서는 네 가지 결과가 있을 수 있다. 테스트는 통과하거나 실패할 수 있다. 그리고 기능이 잘 작동할 수도 있고 고장날 수도 있다.

거짓 음성을피하는 데 좋은 테스트의 첫 번째 특성인 회귀 방지가 도움이 된다.

거짓 양성을 피하는 데 두 번째 특성인 리팩터링 내성이 도움이 된다.

회귀 방지와 리팩터링 내성은 테스트 스위트이 정확도를 극대화하는 것을 목표로 한다. 정확도 지표는 다음 두 가지 요소로 구성된다.


- 테스트가 버그 있음을 얼마나 잘 나타내는가(거짓 음성 제외)
- 테스트가 버그 없을을 얼마나 잘 나타내는가(거짓 양성 제외)

테스트 정확도를 향상시키는 두 가지 방법

테스트 정확도 = 신호(발견된 버그 수)/소음(허위 경보 발생 수)


1. 첫 번째는 분자, 즉 신호를 증가시키는 것. 이는 회귀를 더 잘 찾아내는 테스트로 개선하는 것이다.
2. 두 번째는 분모, 즉 소음을 줄이는 것. 이는 허위 경보를 발생시키지 않는 테스트로 개선하는 것이다.

### 2.2 거짓 양성과 거짓 음성의 중요성


단기적으로는 거짓 양성도 거짓 음성만큼 나쁘지 않다. 프로젝트가 시작될 때, 잘못된 경고를 받는 것은 경고를 전혀 받지 않아 버그가 운영환경에 들어갈 위험을 감수하는 것에 비해 별일이 아니다. 그러나 프로젝트가 성장함에 따라 거짓 양성은 테스트 스위트에 점점 더 큰 영향을 미치기 시작한다.

초기에 왜 거짓 양성이 중요하지 않을까?


- 초기에는 코드 정리를 많이 할 필요가 없다. 하지만 프로젝트가 커질수록 리팩터링이 점점 더 필요해짐에 따라 테스트에서 리팩터링 내성도 점점 더 중요해진다.

## 3. 세 번째 요소와 네 번째 요소: 빠른 피드백과 유지 보수성


`빠른 피드백`

오래 걸리는 테스트는 자주 실행하지 못하기 때문에 잘못된 방향으로 가면서 시간을 더 많이 낭비하게 된다.

`유지 보수성`

유지 보수성 지표는 유지비를 평가한다. 이 지표는 다음 두 가지 주요 요소로 구성된다.


- 테스트가 얼마나 이해하기 어려운가
    - 테스트는 코드 라인이 적을수록 더 읽기 쉽다.
- 테스트가 얼마나 실행하기 어려운가
    - 테스트가 프로세스 외부 종속성으로 작동하면, 데이터베이스 서버를 재부팅하고 네트워크 연결 문제를 해결하는 등 의존성을 상시 운영하는 데 시간을 들여야 한다.

## 4. 이상적인 테스트를 찾아서


좋은 단위 테스트에는 다음 네 가지 특성을 다시 보면 다음과 같다.


- 회귀 방지
- 리팩터링 내성
- 빠른 피드백
- 유지 보수성

이 네 가지 특성을 곱하면 테스트의 가치가 결정된다. 즉, 어떤 특성이라도 0이 되면 전체가 0이된다.

테스트 코드를 포함한 모든 코드는 책임이다. 최소 필수값에 대해 상당히 높은 임계치를 설정하고 이 임계치를 충족하는 테스트만 테스트 스위트에 남겨라. 소수의 매우 가치 있는 테스트는 다수의 평범한 테스트보다 프로젝트가 계속 성장하는 데 훨씬 더 효과적이다.

### 4.1 이상적인 테스트를 만들 수 있는가?


이상적인 테스트는 네 가지 특성 모두에서 최대 점수를 받는 테스트


- 하지만 불가능, 회귀방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문
- 셋 중 하나를 희생해야 나머지 둘을 최대로 할 수 있다.
- 하지만 한가지를 0점으로 만들어서도 안됨
- 그러므로, 특성 중 어느 것도 크게 줄지 않는 방식으로 최대한 크게 해야 한다.

두 특성을 최대로 하는 것을 목표로 해서 한 가지 특성을 희생해 결국 가치가 0에 가까워진 테스트를 몇 가지 예로 살펴보자

###  4.2 극단적인 사례1: 엔드 투 엔드 테스트


엔드 투 엔드 테스트는 최종 사용자의 관점에서 시스템을 살펴본다. 일반적으로 UI, 데이터베이스, 외부 애플리케이션을 포함한 모든 시스템 구성 요소를 거치게 된다.


- 많은 코드를 테스트하므로 회귀 방지를 휼룽히 해냄
- 거짓 양성이 면역이 돼 리팩터링 내성이 우수
    - 리팩터링은 식별할 수 있는 동작을 변경하지 않으므로 영향을 미치지 않는다.
    - 엔드 투 엔드 테스트는 최종 사용자의 관점에서 기능이 어떻게 동작하는지만 볼 수 있으며, 구현 세부 사항을 최대한 제거했기 때문
-  하지만 속도가 느림

###  4.3 극단적인 사례 2: 간단한 테스트

- 간단하므로 테스트가 매우 빠르게 실행되고, 빠른 피드백을 제공함
- 거짓 양성이 생길 가능성이 낮기 때문에 리팩터링 내성도 우수
- 그러나 기반 코드에 실수할 여지가 많지 않기 때문에 간단한 테스트는 회귀를 나타내지 않는다.

###  4.4 극단적인 사례 3:깨지기 쉬운 테스트


깨지기 쉬운 테스트


- 실행이 빠르고 회귀를 잡을 가능성이 높지만 거짓 양성이 많은 테스트

```cs
public class UserRepository
{
  public User GetById(int id)
  {
    /* ... */
  }
}

[Fact]
public void GetById_executes_correct_SQL_code()
{
  var sut = new UserRepository();

  User user = sut.GetById(5);

  Assert.Equal(
    "SELECT * FROM dbo.[User] WHERE UserId = 5",
    sut.LastExecuteSqlStatement);
}
```

- 실행 빠름
- 회귀를 잡을 가능성 높음
    - 개발자가 SQL 코드 생성을 엉망으로 했을 경우 회귀를 잡음
    - UserId대신 ID로 잘못 사용한 경우에도 회귀를 잡음
- 하지만 리팩터링 내성이 낮음
    - SELECT * FROM dbo.[User] WHERE UserId = 5
    - 위 SQL문과 같은 역할을하는 SQL문은 여러개가 존재한다.
    - 즉, 동작에는 이상없지만 테스트는 실패하는 거짓 양성이 발생할 가능성이 높아진다.

###  4.5 이상적인 테스트를 찾아서: 결론


위 사례들과 같이  회귀방지, 리팩터링 내성, 빠른 피드백은 상호 배타적이기 때문에 모두 최대로 만들 수 없다.

그럼 세 가지 특성 모두를 양보한 만큼 서로 조금씩 인정하는 것이 최선의 전략일까?

그러나 실제로는 리팩터링 내성을 조금도 양보할 수 없다.


-  리팩터링 내성의 여부는 **이진 선택**이기 때문 즉, 테스트에 리팩터링 내성이 있거나 없거나 둘 중 하나이기 때문

따라서 테스트가 얼마나 버그를 잘 찾아내는지(회귀 방지)와 얼마나 테스트가 빠른지(빠른 피드백) 사이의 선택으로 절충이 귀결된다.

## 5. 대중적인 테스트 자동화 개념 살펴보기


### 5.1 테스트 피라미드 분해


테스트 피라미드는 테스트 스위트에서 테스트 유형 간의 일정한 비율을 일컫는 개념

테스트 유형 간의 비율은 일반적으로 피라미드 형태를 유지해야한다.


- 즉, 엔드 투 엔드 테스트가 가장 적고, 단위 테스트가 가장 많으며, 통합 테스트는 중간 어딘가에 있어야 한다.

엔드 투 엔드 테스트가 가장 적어야하는 이유


- 위에서 설명한 곱셈 법칙에서 알 수 있음
- 엔드 투 엔드 테스트는 빠른 피드백 지표에서 매우 낮은 점수를 받을 뿐만 아니라 크기가 더 큰 편이라 유지 보수성이 결여되어 있기 때문 즉, 4가지의 지표중 2가지가 낮음 
