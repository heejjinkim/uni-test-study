
# 10. 데이터베이스 테스트

데이터베이스 테스트는 회귀 방지에 뛰어나다.
여기서 말하는 내용은 RDB뿐만 아니라, Document-based DB 등 다른 유형의 데이터 저장에도 적용할 수 있다.

## 데이터베이스 테스트를 위한 전제 조건
### 형상 관리 시스템에 데이터베이스 유지
1. 데이터베이스 스키마
	- 스키마 자체를 코드 취급하여, 형상 관리 시스템에 저장
	- 변경해야 할 모델과 운영 모델을 비교하여 변경 스크립트를 외부에서 실행
	- 단점 : 
		- 변경 내역 부재 : 스키마를 특정 시점으로 되돌릴 수 없다 -> 버그 재현 불가능
		- 소스 코드가 단일 출처가 아님 : 여러 소스코드 버전에 존재할 수 있는데, 모델 데이터베이스는 이 개발 상태와 같지 않을 수 있음
2. 데이터베이스 스키마 업데이트
	- 스키마의 변경 사항을 형상 관리 시스템에 저장
	- 참조 데이터는 이를 참조하는 데이터에게 선행되어야 하는 필수 데이터이므로, 참조 데이터 또한 데이터베이스 스키마에 포함됨
	- 장점 :
		- 일반 코드 변경과 함께 데이터베이스 변경에 대해서도 추적 가능

### 모든 개발자를 위한 별도의 데이터베이스 인스턴스 사용
공유 데이터베이스를 사용하면, 개발 프로세스에 방해된다.
- 서로 다른 개발자가 실행한 테스트가 서로 간섭됨
- 하위 호환성이 없는 변경이 발생하면 다른 개발자의 작업을 막을 수 있기 때문

테스트할 때는 개발자마다 별도로 데이터베이스 인스턴스를 사용해야 한다.

### 데이터베이스 배포에 마이그레이션 기반 방식 적용

데이터베이스 배포를 할 땐 마이그레이션 기반 반식을 적용하는 것이 효과적이다.

#### 상태 기반 방식
1)개발 중에 유지하는 모델 데이터베이스와 2)운영 데이터베이스가 존재      
배포 시에 '비교 도구'가 1)과 2)를 비교하여
- 불필요한 테이블 삭제
- 새 테이블 생성
- 컬럼명 변경
등 동기화에 필요한 모든 작업을 수행한다.

**특징**
- 상태를 형상 관리에 저장
- 비교 도구가 마이그레이션을 암묵적으로 제어
- 병합 충돌을 처리하기 수월함

#### 마이그레이션 방식
어떤 버전에서 다른 버전으로 전환하는 명시적인 마이그레이션

상태 기반에서 사용한 '비교 도구'는 사용할 수 없다.     
업그레이드 스크립트를 직접 작성해야 한다.      

이 스크립트를 형상 관리 시스템에 저장하여 변경 사항을 추적할 수 있고 실제 상태도 변경할 수 있다.

1. DDL 직접 작성
	- 일반적으로 알고 있는 `CREATE TABLE`, `ALTER TABLE` 등 SQL 명령어
2. DSL 작성
	- java, c# 등 언어로 DDL를 대신할 수 있는 메소드
	- Java 진영에는 Flyway, Liquibase 등이 있다.

**특징**
- 마이그레이션을 명시적으로 형상 관리에 저장
- 상태는 암묵적으로 제어
- DB 상태를 직접볼 수 없으며 마이그레이션으로 조합해야 함
- 데이터 모션 문제를 해결하는 데 수월함

데이터 모션 : 새로운 DB 스키마를 준수하도록 기존 데이터의 형태를 변경하는 과정

#### 마이그레이션 방식이 더 중요한 이유

데이터 모션 작업이 대부분 프로젝트에서 더 중요하기 때문

예시) Name 필드를 First Name과 Second Name으로 분리하는 경우      
스키마는 객관적이지만, 데이터는 주관적이다.      
따라서 데이터를 변경하려면 도메인에 특화된 규칙을 적용해야 한다. 비교 도구는 주관적인 것을 해결할 수 없다.


## DB 트랜잭션 관리

### 제품 코드에서 트랜잭션 관리
트랜잭션에서 가장 중요한 것 : 모든 업데이트는 원자적이어야 한다.

#### 데이터 접근과 트랜잭션 분리

컨트롤러는 업데이트를 수행할 지 말지의 여부만 알면 된다. 따라서, 데이터 접근과 트랜잭션을 분리하는 것이 중요하다.
- Repository : 데이터베이스의 데이터에 대한 접근과 수정을 하는 클래스
- Transaction : 데이터 업데이트를 커밋하거나 롤백하는 클래스

트랜잭션이 먼저 동작한 후, 리포지토리의 동작이 수행된다.    
즉, 모든 리포지터리는 항상 현태 트랜잭션 위에서 작동한다. 그렇기 때문에 리포지터리는 스스로 데이터베이스를 호출할 수 없다.

#### 작업 단위 패턴(Unit of Work Pattern)
커밋을 마지막에 한 번만 하도록, 객체의 변경 스냅샷을 메모리에서 추척한다(업데이트 지연)


**장점**
- 데이터베이스 트랜잭션의 기간 단축
- 데이터 혼잡 줄일 수 있음
- 데이터베이스 호출 수도 줄일 수 있음

JPA에서도 이러한 방법을 사요하고 있다.
- `Persistance Context`에서 상태를 관리
- `commit()` 대신 `save()`/`setter()` 를 통해서 DB에 변경 사항 커밋

### 통합 테스트에서 트랜잭션 관리

- 테스트의 구절 간(준비/실행/검증) 트랜잭셔 재사용하지 않아야 한다.
	- Context에서 메모리에 저장된 데이터가 있을 수 있음
- 입력 매개변수와 별개로 "데이터베이스"의 상태를 확인하는 것이 중요하다.
- 따라서 각 구절(준비, 실행, 검증)에서 각자 다른 트랜잭션/작업 단위를 사용하는 것이 좋다.


